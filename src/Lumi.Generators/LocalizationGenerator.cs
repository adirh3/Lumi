using System;
using System.Collections.Generic;
using System.Collections.Immutable;
using System.Globalization;
using System.IO;
using System.Linq;
using System.Text;
using Microsoft.CodeAnalysis;
using Microsoft.CodeAnalysis.Text;

namespace Lumi.Generators;

/// <summary>
/// Source generator that reads JSON localization files (AdditionalFiles) and produces
/// a partial <c>Loc</c> class with:
/// <list type="bullet">
///   <item>One <c>{ get; private set; }</c> property per key, initialized with the English value.</item>
///   <item>Per-language string arrays for <c>SelectLanguage</c> to copy from at startup.</item>
///   <item>A <c>FrozenDictionary&lt;string, int&gt;</c> for dynamic XAML key lookup.</item>
/// </list>
/// Properties are direct field reads — zero indirection at the call site.
/// </summary>
[Generator]
public sealed class LocalizationGenerator : IIncrementalGenerator
{
    public void Initialize(IncrementalGeneratorInitializationContext context)
    {
        var jsonFiles = context.AdditionalTextsProvider
            .Where(static f => f.Path.EndsWith(".json", StringComparison.OrdinalIgnoreCase));

        context.RegisterSourceOutput(
            jsonFiles.Collect(),
            static (ctx, files) => Execute(ctx, files));
    }

    private static void Execute(SourceProductionContext ctx, ImmutableArray<AdditionalText> files)
    {
        if (files.IsDefaultOrEmpty) return;

        // Parse each JSON file
        var languages = new List<LangData>();
        foreach (var file in files)
        {
            var content = file.GetText(ctx.CancellationToken)?.ToString();
            if (string.IsNullOrWhiteSpace(content)) continue;

            var code = Path.GetFileNameWithoutExtension(file.Path);
            var entries = ParseJson(content!);
            if (entries.Count > 0)
                languages.Add(new LangData { Code = code, Entries = entries });
        }

        if (languages.Count == 0) return;

        // Ensure English is first (fallback)
        languages.Sort((a, b) =>
        {
            if (a.Code.Equals("en", StringComparison.OrdinalIgnoreCase)) return -1;
            if (b.Code.Equals("en", StringComparison.OrdinalIgnoreCase)) return 1;
            return string.Compare(a.Code, b.Code, StringComparison.Ordinal);
        });

        var fallback = languages[0];
        var keys = new List<string>(fallback.Entries.Count);
        var fallbackDict = new Dictionary<string, string>(fallback.Entries.Count);
        foreach (var kv in fallback.Entries)
        {
            keys.Add(kv.Key);
            fallbackDict[kv.Key] = kv.Value;
        }

        // ── Generate C# source ──
        var sb = new StringBuilder(32768);

        sb.AppendLine("// <auto-generated/>");
        sb.AppendLine("#nullable enable");
        sb.AppendLine();
        sb.AppendLine("using System.Collections.Frozen;");
        sb.AppendLine("using System.Collections.Generic;");
        sb.AppendLine();
        sb.AppendLine("namespace Lumi.Localization;");
        sb.AppendLine();
        sb.AppendLine("partial class Loc");
        sb.AppendLine("{");

        // ── Non-English language arrays (English values are in the properties) ──
        foreach (var lang in languages)
        {
            if (lang.Code.Equals("en", StringComparison.OrdinalIgnoreCase)) continue;

            var id = SanitizeIdentifier(lang.Code);
            var dict = new Dictionary<string, string>(lang.Entries.Count);
            foreach (var kv in lang.Entries)
                dict[kv.Key] = kv.Value;

            sb.Append("    private static readonly string[] _lang_").Append(id).AppendLine(" =");
            sb.AppendLine("    [");
            for (int i = 0; i < keys.Count; i++)
            {
                var key = keys[i];
                string value;
                if (!dict.TryGetValue(key, out value!))
                    value = fallbackDict[key]; // fallback for missing keys

                sb.Append("        \"").Append(EscapeCSharp(value)).Append("\", // ").Append(i).Append(": ").AppendLine(key);
            }
            sb.AppendLine("    ];");
            sb.AppendLine();
        }

        // ── Language registry ──
        sb.AppendLine("    private static readonly FrozenDictionary<string, string[]> _langMap =");
        sb.AppendLine("        new Dictionary<string, string[]>");
        sb.AppendLine("        {");
        foreach (var lang in languages)
        {
            if (lang.Code.Equals("en", StringComparison.OrdinalIgnoreCase)) continue;
            sb.Append("            [\"").Append(lang.Code).Append("\"] = _lang_").Append(SanitizeIdentifier(lang.Code)).AppendLine(",");
        }
        sb.AppendLine("        }.ToFrozenDictionary();");
        sb.AppendLine();

        // ── Key → index FrozenDictionary (for XAML dynamic lookup) ──
        sb.AppendLine("    private static readonly FrozenDictionary<string, int> _keyIndex =");
        sb.AppendLine("        new Dictionary<string, int>");
        sb.AppendLine("        {");
        for (int i = 0; i < keys.Count; i++)
            sb.Append("            [\"").Append(keys[i]).Append("\"] = ").Append(i).AppendLine(",");
        sb.AppendLine("        }.ToFrozenDictionary();");
        sb.AppendLine();

        // ── Typed properties — direct field read, zero overhead ──
        for (int i = 0; i < keys.Count; i++)
        {
            var key = keys[i];
            if (!IsValidCSharpIdentifier(key)) continue;
            var englishValue = fallbackDict[key];
            sb.Append("    public static string ").Append(key).Append(" { get; private set; } = \"").Append(EscapeCSharp(englishValue)).AppendLine("\";");
        }
        sb.AppendLine();

        // ── Dynamic lookup (for XAML {loc:Str Key}) ──
        sb.AppendLine("    private static string GetByKey(string key)");
        sb.AppendLine("    {");
        sb.AppendLine("        if (!_keyIndex.TryGetValue(key, out var i)) return key;");
        sb.AppendLine("        return i switch");
        sb.AppendLine("        {");
        for (int i = 0; i < keys.Count; i++)
        {
            var key = keys[i];
            if (IsValidCSharpIdentifier(key))
                sb.Append("            ").Append(i).Append(" => ").Append(key).AppendLine(",");
            else
                sb.Append("            // ").Append(i).Append(": ").Append(key).AppendLine(" (not a valid identifier)");
        }
        sb.AppendLine("            _ => key");
        sb.AppendLine("        };");
        sb.AppendLine("    }");
        sb.AppendLine();

        // ── Language selector — copies values from array into properties once ──
        sb.AppendLine("    private static void SelectLanguage(string lang)");
        sb.AppendLine("    {");
        sb.AppendLine("        if (!_langMap.TryGetValue(lang, out var src)) return;");
        for (int i = 0; i < keys.Count; i++)
        {
            var key = keys[i];
            if (IsValidCSharpIdentifier(key))
                sb.Append("        ").Append(key).Append(" = src[").Append(i).AppendLine("];");
        }
        sb.AppendLine("    }");

        sb.AppendLine("}");

        ctx.AddSource("Loc.g.cs", SourceText.From(sb.ToString(), Encoding.UTF8));
    }

    // ── Helpers ──

    private sealed class LangData
    {
        public string Code = "";
        public List<KeyValuePair<string, string>> Entries = new List<KeyValuePair<string, string>>();
    }

    /// <summary>Parses a flat {"key": "value", …} JSON object preserving insertion order.</summary>
    private static List<KeyValuePair<string, string>> ParseJson(string json)
    {
        var result = new List<KeyValuePair<string, string>>();
        int pos = 0;
        int len = json.Length;

        // Skip to opening brace
        while (pos < len && json[pos] != '{') pos++;
        pos++;

        while (pos < len)
        {
            SkipWhitespace(json, ref pos, len);
            if (pos >= len || json[pos] == '}') break;

            if (json[pos] != '"') { pos++; continue; }
            var key = ReadJsonString(json, ref pos, len);

            SkipWhitespace(json, ref pos, len);
            if (pos < len && json[pos] == ':') pos++;
            SkipWhitespace(json, ref pos, len);

            if (pos >= len || json[pos] != '"') { pos++; continue; }
            var value = ReadJsonString(json, ref pos, len);

            result.Add(new KeyValuePair<string, string>(key, value));

            SkipWhitespace(json, ref pos, len);
            if (pos < len && json[pos] == ',') pos++;
        }

        return result;
    }

    private static void SkipWhitespace(string s, ref int pos, int len)
    {
        while (pos < len)
        {
            char c = s[pos];
            if (c != ' ' && c != '\t' && c != '\n' && c != '\r') break;
            pos++;
        }
    }

    /// <summary>Reads a JSON string literal starting at the opening quote, advancing pos past the closing quote.</summary>
    private static string ReadJsonString(string json, ref int pos, int len)
    {
        pos++; // skip opening "
        var sb = new StringBuilder();

        while (pos < len)
        {
            char c = json[pos++];
            if (c == '"') break;
            if (c == '\\' && pos < len)
            {
                char next = json[pos++];
                switch (next)
                {
                    case '"': sb.Append('"'); break;
                    case '\\': sb.Append('\\'); break;
                    case '/': sb.Append('/'); break;
                    case 'b': sb.Append('\b'); break;
                    case 'f': sb.Append('\f'); break;
                    case 'n': sb.Append('\n'); break;
                    case 'r': sb.Append('\r'); break;
                    case 't': sb.Append('\t'); break;
                    case 'u':
                        if (pos + 4 <= len)
                        {
                            var hex = json.Substring(pos, 4);
                            sb.Append((char)int.Parse(hex, NumberStyles.HexNumber));
                            pos += 4;
                        }
                        break;
                    default:
                        sb.Append(next);
                        break;
                }
            }
            else
            {
                sb.Append(c);
            }
        }

        return sb.ToString();
    }

    /// <summary>Escapes a string for use inside a C# string literal.</summary>
    private static string EscapeCSharp(string s)
    {
        var sb = new StringBuilder(s.Length + 16);
        foreach (char c in s)
        {
            switch (c)
            {
                case '"': sb.Append("\\\""); break;
                case '\\': sb.Append("\\\\"); break;
                case '\n': sb.Append("\\n"); break;
                case '\r': sb.Append("\\r"); break;
                case '\t': sb.Append("\\t"); break;
                case '\0': sb.Append("\\0"); break;
                default:
                    if (char.IsControl(c))
                        sb.Append("\\u").Append(((int)c).ToString("X4"));
                    else
                        sb.Append(c);
                    break;
            }
        }
        return sb.ToString();
    }

    /// <summary>Makes a language code safe for use as a C# identifier (e.g. "pt-BR" → "pt_BR").</summary>
    private static string SanitizeIdentifier(string code)
        => code.Replace('-', '_').Replace('.', '_');

    /// <summary>Checks whether a string is a valid C# identifier (letters, digits, underscores).</summary>
    private static bool IsValidCSharpIdentifier(string name)
    {
        if (string.IsNullOrEmpty(name)) return false;
        if (!char.IsLetter(name[0]) && name[0] != '_') return false;
        for (int i = 1; i < name.Length; i++)
            if (!char.IsLetterOrDigit(name[i]) && name[i] != '_') return false;
        return true;
    }
}
